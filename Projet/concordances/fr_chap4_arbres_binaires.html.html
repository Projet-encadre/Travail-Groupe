<html><body><table border='1'>
<tr><th>Left Context</th><th>Target Word</th><th>Right Context</th></tr>
<tr><td>None est donc un arbre (l'arbre vide). Un arbre non vide possèdera donc</td><td>racine</td><td></td></tr>
<tr><td>3 attributs :</td><td>racine</td><td></td></tr>
<tr><td>* Une étiquette (label) qui est le nom de la </td><td>racine</td><td>. C'est une chaîne</td></tr>
<tr><td>de caractères.</td><td>racine</td><td></td></tr>
<tr><td>* L'enfant gauche (G) qui est un arbre binaire (éventuellement vide).</td><td>racine</td><td></td></tr>
<tr><td>* L'enfant droit (D) qui est un arbre binaire (éventuellement vide)</td><td>racine</td><td></td></tr>
<tr><td></td><td>racine</td><td></td></tr>
<tr><td>Si T est un objet de type Arbre (binaire) alors sa </td><td>racine</td><td> a pour nom</td></tr>
<tr><td>T.label, son enfant gauche est T.G et son enfant droit est T.D. On peut</td><td>racine</td><td></td></tr>
<tr><td>créer un arbre binaire T de </td><td>racine</td><td> R en faisant T = Arbre('R'). Pour</td></tr>
<tr><td>cela il suffit de définir une classe Arbre.</td><td>racine</td><td></td></tr>
<tr><td></td><td>racine</td><td></td></tr>
<tr><td>--</td><td>racine</td><td></td></tr>
<tr><td>à droite, ce qui est résumé par T.D.G.D. En codant chaque virage à</td><td>racine</td><td></td></tr>
<tr><td>gauche par un 0 et chaque virage à droite par un 1, I est représenté</td><td>racine</td><td></td></tr>
<tr><td>par 101 en binaire. Chaque noeud autre que la </td><td>racine</td><td> possède ainsi un</td></tr>
<tr><td>code binaire.</td><td>racine</td><td></td></tr>
<tr><td></td><td>racine</td><td></td></tr>
<tr><td>--</td><td>racine</td><td></td></tr>
<tr><td>Pour effectuer un parcours de l'arbre en largeur, on définit la notion</td><td>racine</td><td></td></tr>
<tr><td>de niveau d'un noeud :</td><td>racine</td><td></td></tr>
<tr><td>* La </td><td>racine</td><td> est au niveau 0.</td></tr>
<tr><td>* Les enfants d'un noeud au niveau n-1 sont au niveau n.</td><td>racine</td><td></td></tr>
<tr><td></td><td>racine</td><td></td></tr>
<tr><td>--</td><td>racine</td><td></td></tr>
<tr><td>Pour l'arbre A, la liste renvoyée est [['A'], ['B', 'C'], ['D', 'E',</td><td>racine</td><td></td></tr>
<tr><td>'F', 'G'], ['H', 'I']] ce qui signifie qu'il y a</td><td>racine</td><td></td></tr>
<tr><td>* Un seul noeud au niveau 0 : la </td><td>racine</td><td> A.</td></tr>
<tr><td>* Deux noeuds au niveau 1 : B, C.</td><td>racine</td><td></td></tr>
<tr><td>* Quatre noeuds au niveau 2 : D, E, F, G.</td><td>racine</td><td></td></tr>
<tr><td>--</td><td>racine</td><td></td></tr>
<tr><td>équilibré. Mais ses feuilles portant des lettres, il sert à décoder des</td><td>racine</td><td></td></tr>
<tr><td>mots binaires écrits avec les 13 lettres. Par exemple pour arriver à la</td><td>racine</td><td></td></tr>
<tr><td>lettre T on effectue (depuis la </td><td>racine</td><td>) le trajet GDD et la lettre T se</td></tr>
<tr><td>code 011. On peut vérifier que les 13 bits 0111100101000 représentent</td><td>racine</td><td></td></tr>
<tr><td>le code de Huffman du mot TAIE qui s'écrit sur 32 bits en Ascii et au</td><td>racine</td><td></td></tr>
</table></body></html>
